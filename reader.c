#define _XOPEN_SOURCE 700

#include "platform.h"

#include <sys/mman.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <string.h>
#include <strings.h>
#include <ctype.h>
#include <errno.h>
#include <limits.h>
#include <getopt.h>
#include <sysexits.h>
#include <dirent.h>
#include <libgen.h>

#include "parser.h"
#include "filter.h"
#include "list_template.h"
#include "array_length.h"
#include "trace_str_util.h"
#include "opt_util.h"
#include "file_naming.h"

enum op_type_e {
    OP_TYPE_INVALID,
    OP_TYPE_DUMP_STATS,
    OP_TYPE_DUMP_FILE,
    OP_TYPE_DUMP_METADATA
};


struct trace_reader_conf {
    enum op_type_e op_type;
    int severity_level;
    int tail;
    int no_color;
    int hex;
    enum trace_parser_param_name_disp_mode field_disp;
    int show_trace_file;
    int hide_funtion_name;
    int nanoseconds_ts;
    int empty_timestamp;
    int compact_trace;
    int show_pid;
    int free_dead_process_metadata;
    // long long from_time;
    int after_count;
    unsigned max_errors_per_file;
    const char **files_to_process; /* A NULL terminated array of const char* */
    struct trace_record_matcher_spec_s *record_filter;
    struct trace_filter_collection filter;
};

#ifdef  _USE_PROC_FS_
#define _ENABLE_ACTIVE_FILE_INFERENCE_
#endif


#define TRACE_SEV_X(ignored, sev) "/" #sev
#define TRACE_LEVELS_STR "FUNC" TRACE_SEVERITY_DEF


static const char usage[] =
    "Usage: %s [params] "
#ifdef _ENABLE_ACTIVE_FILE_INFERENCE_
		"["
#endif
		"file(s)"
#ifdef _ENABLE_ACTIVE_FILE_INFERENCE_
		"]"
#endif
		"\n\
    Actions:\n\
     (DEFAULT ACTION)    : Dump contents of trace file \n\
 -s  --print-stats       : Print per-log occurrence count \n\
 -m  --dump-metadata     : Dump metadata \n\
 -i  --tail              : Display last records and wait for more data \n\
 -h, --help              : Display this help message \n\
 \n\
    Displays: \n\
 -N  --no-color          : Disable ansii colors (big output is also a little faster) \n\
 -X  --hex               : Display all numeric values in hexadecimal \n\
 -Q  --quota-max [num]   : Show no more than [num] traces (technicaly it's a filter, but 'gimme a break) \n\
 -A  --after     [num]   : Show [num] traces of the same thread after each hit (TBD: -B/C) \n\
 -F  --no-function       : Avoid displaying function names \n\
 -L  --show-trace-file   : Display faked log messages with trace's file name \n\
 -E  --no-timestamp      : Avoid displaying timestamp, process name/id (mnemonic - EMPty) \n\
 -I --pid                : Show process-id \n\
 -M  --compact-traces    : Compact trace output \n\
 -P  --nano-timestamp    : Print timestamps as raw nano-seconds-since-Epoch units \n\
 -O  --field-names [a[ll] | e[xplicit] (default) | f[ield] | n[one]]: Parameter name display mode \n\
 \n\
    Filters: \n\
 -t  --time   [time]     : Used once or twice to set a time range. [time] may be nanoseconds int, or time format string \n\
 -l  --level  [severity] : Match: severity and up. Int value or " TRACE_LEVELS_STR " (DEFAULT: TRIO) \n\
 -g  --grep   [str]      : Match: constant string contains [str] \n\
 -c  --strcmp [str]      : Match: constant string exact-matches [str] (faster than -g, useful to filter MODULE)\n\
 -v  --value  [num ]     : Match: int value equal to [num] \n\
 -v  --value  [name=num] : Match: specific name field [name] equal to [num] (as name apears with -O) \n\
 -u  --value2 [num] or [name=num] : similar to -v \n\
 -w  --value3 [num] or [name=num] : similar to -v and -u \n\
 -z  --fuzzy  [??? ]     : - If [???] looks like a number, similar to -v [num], else similar to -g [str] \n\
 -f  --function [func]   : Match traces generated by [func] (exact match) \n\
 -d  --tid    [num]      : Match only thread id [num] (thread names - TBD)\n\
 \n\
    Filters Rules: \n\
 * legal -t values: '2012/09/03_05:10:56_676665242', '2012/09/03_05:10:56' (zero padded), '1346649056676293891' (as in -P) \n\
 * Different options are bound with AND \n\
 * Filter options can be repeated, repetitions are bound with OR (exceptioned by -t) \n\
 * Enums can be filtered as literal numbers (named enums - TBD) \n\
 * Instead of 'name=num' one can use 'name<num' or 'name>num' (quote to avoid shell's redirection, unsigned only) \n\
    Examples: \n\
 '-l WARN'                               shows warnings, errors, and fatal traces\n\
 '-g snap -v a_vu=0 -v 333 -g remove'    means 'str(snap) && (named_val(a_vu, 0) || val(333)) && str(remove) \n\
 '-g str1 -v 111 -z 222 -z 333 -z str2'  means 'str(str1) && val(111) && (val(222) || val(333) || str(str2))' \n\
 '-c CACHE -v a_lba=1442'                means 'CACHE && lba(1442)' \n\
 '-c CACHE -v a_lba=1442' -v a_lba=1444' means 'CACHE && (lba(1442) || lab(1444))' \n\
 \"-v 'vu<4' -w 'vu>1' -Q20 \"           same as '-v vu=2 -v -Q20' \n\
\n"
#ifdef _ENABLE_ACTIVE_FILE_INFERENCE_
		"\nIf the trace-file to be displayed is not specified the reader will attempt to detect it automatically\n"
#endif
 ;

static const char invalid_severity_msg[] = "Severity format may be a number, or " TRACE_LEVELS_STR;

#undef TRACE_SEV_X

static const struct option longopts[] = {
	// { "dump"            , 0, 0, 'd'},
    { "print-stats"     , 0, 0, 's'},
    { "dump-metadata"   , 0, 0, 'm'},
    { "tail"            , 0, 0, 'i'},
    { "help"            , 0, 0, 'h'},

	{ "no-color"        , 0, 0, 'N'},
    { "hex"             , 0, 0, 'X'},
    { "quota-max"       , required_argument, 0, 'Q'},
    { "after"           , required_argument, 0, 'A'},
    { "no-function"     , 0, 0, 'F'},
    { "no-timestamp"    , 0, 0, 'E'},
    { "show-trace-file" , 0, 0, 'L'},
    { "no-timestamp"    , 0, 0, 'E'},
    { "pid"             , 0, 0, 'I'},
    { "compact-trace"   , 0, 0, 'M'},
    { "nano-timestamp"  , 0, 0, 'P'},
    { "field-names"     , optional_argument, 0, 'O'},

    { "time"            , required_argument, 0, 't'},
    { "level"           , required_argument, 0, 'l'},
    { "grep"            , required_argument, 0, 'g'},
    { "strcmp"          , required_argument, 0, 'c'},
    { "value"           , required_argument, 0, 'v'},
    { "value2"          , required_argument, 0, 'u'},
    { "value3"          , required_argument, 0, 'w'},
    { "fuzzy"           , required_argument, 0, 'z'},
    { "function"        , required_argument, 0, 'f'},
    { "tid"             , required_argument, 0, 'd'},
	{ 0, 0, 0, 0}
};

static int exit_usage(const char *prog_name, const char* more)
{
    if (prog_name) {
        if (more)
            fprintf(stderr, "\n%s\n", more);

        fprintf(stderr, usage, prog_name);
        exit(more ? EX_USAGE : 0);
    }

    fprintf(stderr, "%s\n%s\n", more, "    Please use --help option (-h) for full usage ");
    exit(EX_USAGE);
    return 0;                   /* happy compiler */
}

static void fatal_usage_err_handler(const char *msg)
{
    exit_usage(NULL, msg);
}

static int get_severity_level(const char* str) {
    long long n;
    return 
        trace_get_number(str, &n)           ? n :
        (0 == strcasecmp(str, "FUNC")) ? TRACE_SEV_FUNC_TRACE :
        ((n = trace_str_to_severity_case_insensitive(str)) != TRACE_SEV_INVALID) ? n :
        exit_usage(NULL, invalid_severity_msg);
}

#ifdef _ENABLE_ACTIVE_FILE_INFERENCE_

static void tokenize_cmdline(char* cmdline, int len, int* argc, char** argv,int MAX_ARGS)
{
    char* p;

    *argc = 0;

    argv[(*argc)++] = cmdline;

    for (p = cmdline; p < cmdline + len; ++p) {
        if (*p == '\0') {
            argv[(*argc)++] = p + 1;
        }
        if (*argc >= MAX_ARGS) {
            break;
        }
    }
}

static int get_active_workdir(char* workdir, int len, pid_t* pid)
{
    DIR *d;
    int result = -1;
    char tmp[PATH_MAX];
    char cmdline[4096];
    int fd;
    int n;

    d = opendir("/proc");
    if (!d) {
        return -1;
    }

    while (1) {
        struct dirent *e;
        e = readdir(d);
        if (e == NULL) {
            break;
        }

        if (atoi(e->d_name) <= 0) {
            continue;
        }

        n = snprintf(tmp, sizeof(tmp), "/proc/%s/cmdline", e->d_name);
        if (n <= 0 || n >= (int)sizeof(tmp)) {
            continue;
        }

        fd = open(tmp, 0);
        if (fd < 0) {
            continue;
        }
        n = read(fd, cmdline, sizeof(cmdline));
        close(fd);
        if (n <= 0 || n >= (int)sizeof(cmdline) - 2) {
            continue;
        }
    
        cmdline[n] = cmdline[n + 1] = '\0';
        
        if (strcmp(basename(cmdline), "trace_dumper") != 0) {
            continue;
        }

        char* argv[64];
        int argc = 0;
        tokenize_cmdline(cmdline, n, &argc, argv, sizeof(argv) / sizeof(argv[0]));

        int i;
        for (i = 0; i < argc - 1; ++i) {
            if (strcmp(argv[i], "-b") == 0) {
                *pid = atoi(e->d_name);
                n = snprintf(workdir, len, "%s", argv[i + 1]);
                if (n > 0 && n < len) {
                    result = 0;
                }
                goto out;
            }
        }
    }

out:
    closedir(d);

    return result;
}


static int get_active_tracefile(char* filename, int len)
{
    char workdir[PATH_MAX];
    DIR *d;
    int rc;
    int result = -1;
    int n;
    time_t latest = 0;
    struct stat stat_buf;
    pid_t pid;

    rc = get_active_workdir(workdir, sizeof(workdir), &pid);
    if (rc == -1) {
        return result;
    }

    d = opendir(workdir);
    if (!d) {
        return result;
    }

    while (1) {
        struct dirent *e;
        e = readdir(d);
        if (e == NULL) {
            break;
        }
        
        if (! trace_is_valid_file_name(e->d_name)) {
        	continue;
        }

        if (fstatat(dirfd(d), e->d_name, &stat_buf, 0) != 0) {
            continue;
        }

        if (!S_ISREG(stat_buf.st_mode)) {
            continue;
        }

        if (latest < stat_buf.st_mtime) {
            latest = stat_buf.st_mtime;
            n = snprintf(filename, len, "%s/%s", workdir, e->d_name);
            if (n <= 0 || n >= len) {
                result = -1;
            } else {
                result = 0;
            }
        }
    }

    closedir(d);

    return result;
}

#endif

static int parse_command_line(struct trace_reader_conf *conf, int argc, const char **argv)
{
    int o;
    int longindex;
    long long num;

    char shortopts[MAX_SHORT_OPTS_LEN(ARRAY_LENGTH(longopts))];
    short_opts_from_long_opts(shortopts, longopts);

    conf->op_type = OP_TYPE_DUMP_FILE;
    conf->field_disp = TRACE_PARSER_PARAM_NAME_DISP_EXPLICIT;

    /* TODO: The following should be made configurable via e.g. a resource file or similar mechanism. */
    conf->max_errors_per_file = UINT_MAX;

    while ((o = getopt_long(argc, (char **)argv, shortopts, longopts, &longindex)) != EOF) {
		switch (o) {
		case 'h':
		case '?':
			return 1;
        case 'l':
            conf->severity_level = get_severity_level(optarg);
            break;
		case 's':
			conf->op_type = OP_TYPE_DUMP_STATS;
			break;

        case 'O':
            if (optarg) {
                switch(tolower(optarg[0])) {
                case 'a':
                    conf->field_disp = TRACE_PARSER_PARAM_NAME_DISP_ALL;
                    break;
                case 'e':
                     conf->field_disp = TRACE_PARSER_PARAM_NAME_DISP_EXPLICIT;
                     break;
                case 'f':
                     conf->field_disp = TRACE_PARSER_PARAM_NAME_DISP_LAST_FIELD;
                     break;
                case '\0':
                case 'n':
                     conf->field_disp = TRACE_PARSER_PARAM_NAME_DISP_NONE;
                     break;
                default:
                    exit_usage(NULL, "-O [option] : Option must be one of a[ll] | e[xplicit] | f[ield] | n[one]");
                }
            }
            else {
                conf->field_disp = TRACE_PARSER_PARAM_NAME_DISP_NONE;
            }
            break;
        case 'F':
            conf->hide_funtion_name = TRUE;
            break;
        case 'L':
            conf->show_trace_file = TRUE;
            break;
        case 'X':
            conf->hex = TRUE;
            break;
        case 'N':
            conf->no_color = 1;
            break;
        case 'E':
            conf->empty_timestamp = 1;
            break;
        case 'I':
            conf->show_pid = 1;
            break;
        case 'M':
            conf->compact_trace = 1;
            break;
        case 'P':
            conf->nanoseconds_ts = 1;
            break;

        case 'i':
            conf->tail = 1;
            break;
        case 'm':
            conf->op_type = OP_TYPE_DUMP_METADATA;
            break;

        case 'A':
            {
                if (! trace_get_number(optarg, &num))
                    exit_usage(NULL, "-A [val] : [val] must be a legal (positive) number");
                conf->after_count = num > 0 ? num : 0;
            }
            break;

        default:
            if (! trace_filter_init_from_cmdline(&conf->filter, o, optarg, fatal_usage_err_handler)) {
                conf->op_type = OP_TYPE_INVALID;
            }

            break;
        }
    }

    unsigned long filename_index = optind;
    conf->files_to_process = argv + (int)filename_index;

#ifdef _ENABLE_ACTIVE_FILE_INFERENCE_

    if (NULL == *(conf->files_to_process)) {
        static char filename[PATH_MAX];
        static const char* args[2] = { filename, NULL };
        int rc = get_active_tracefile(filename, sizeof(filename));

        if (rc == 0) {
            conf->files_to_process = (const char**)args;
        }
    }

#endif

    if (NULL == *(conf->files_to_process))
    	exit_usage(NULL, "Must specify input files");

    return 0;
}

int read_event_handler(struct trace_parser  __attribute__((unused)) *parser, enum trace_parser_event_e  __attribute__((unused)) event, void  __attribute__((unused)) *event_data, void  __attribute__((unused)) *arg)
{
    return 0;
}

static void set_conf_filter(struct trace_reader_conf *conf)
{
    const unsigned severity = ((conf->severity_level < TRACE_SEV__MIN ||
                           conf->severity_level > TRACE_SEV__MAX) ?
                          TRACE_SEV_TRIO : (conf->severity_level)) ;

    assert(NULL == conf->record_filter);
    conf->record_filter = trace_filter_create_chain(&conf->filter, severity);
}

static void set_parser_params(const struct trace_reader_conf *conf, trace_parser_t *parser)
{
    parser->record_filter = conf->record_filter;
    parser->nanoseconds_ts     = conf->nanoseconds_ts;
    parser->show_timestamp     = ! conf->empty_timestamp;
    parser->color              = ! conf->no_color;
    parser->indent             = conf->severity_level <= TRACE_SEV_FUNC_TRACE;
    parser->field_disp         = conf->field_disp;
    parser->show_function_name = ! conf->hide_funtion_name; 
    parser->compact_traces     = conf->compact_trace;
    parser->show_pid           = conf->show_pid;
    parser->always_hex         = conf->hex;
    parser->after_count        = conf->after_count;
    parser->free_dead_buffer_contexts = conf->free_dead_process_metadata;
}

static int init_parser_for_file(const struct trace_reader_conf *conf, trace_parser_t *parser, bool_t wait_for_input, const char *filename, trace_parser_event_handler_t event_handler)
{
    int rc = TRACE_PARSER__from_file(parser, wait_for_input, filename, event_handler, NULL);
    if (0 != rc) {
        fprintf(stderr, "Error %d opening file %s (%s)\n", errno, filename, strerror(errno));
        return -1;
    }
    set_parser_params(conf, parser);
    parser->show_filename = conf->show_trace_file ? filename : NULL;
    return 0;
}

static int process_single_file_with_error_recovery(
        const struct trace_reader_conf *conf,
        const char *filename,
        bool_t may_wait_for_input,
        trace_parser_event_handler_t event_handler,
        int (*file_handler)(trace_parser_t *)
        )
{
    trace_parser_t parser;
    if (0 != init_parser_for_file(conf, &parser, may_wait_for_input && conf->tail, filename, event_handler)) {
        return EX_NOINPUT;
    }

    int error_occurred = 0;
    unsigned records_rendered_count = parser.records_rendered_count;
    unsigned err_count = 0;
    while (err_count < conf->max_errors_per_file) {
        if (file_handler(&parser) >= 0) {
            break;
        }
        else {
            error_occurred = errno;
            if (EINVAL != error_occurred) {
                fprintf(stderr, "Unrecoverable error %d (%s) while processing the file %s\n", error_occurred, strerror(error_occurred), filename);
                err_count++;
                break;
            }

            /* Check if there were valid records since the last error */
            if (parser.records_rendered_count > records_rendered_count) {
                fprintf(stderr, "Record corruption encountered at offset %#llx while processing the file %s\n", parser.file_info.current_offset, filename);
                err_count++;
                records_rendered_count = parser.records_rendered_count;
            }
        }
    }

    TRACE_PARSER__fini(&parser);

    if (err_count > 0) {
        fprintf(stderr, "Encountered %u errors while processing the file %s, last of them with code %d (%s)\n",
                err_count, filename, error_occurred, strerror(error_occurred));
        if (err_count >= conf->max_errors_per_file) {
            fprintf(stderr, "Quit processing the file %s due to too many errors\n", filename);
        }

        errno = error_occurred;
        return EX_IOERR;
    }

    return 0;
}

static void report_file_error_if_necessary(const char *last_err_file, int latest_err_code) {
    if (NULL != last_err_file) {
       fprintf(stderr, "Trace reader has encountered errors, last of them being %s in the file %s\n",
               strerror(latest_err_code), last_err_file);
   }
}


static int process_files_with_error_recovery(
        const struct trace_reader_conf *conf,
        bool_t may_wait_for_input,
        int (*file_handler)(trace_parser_t *)
        )
{
    const char *last_err_file = NULL;
    int last_err_status = 0;
    int latest_err_code = 0;
    const char **filenames;
    
    for (filenames = conf->files_to_process; *filenames; filenames++) {
        const char *const filename = *filenames;
        const int rc = process_single_file_with_error_recovery(conf, filename, may_wait_for_input, read_event_handler, file_handler);
        if (0 != rc) {
            latest_err_code = errno;
            last_err_status = rc;
            last_err_file = filename;
        }
    }

    report_file_error_if_necessary(last_err_file, latest_err_code);
    return last_err_status;
}

static int dump_all_files(struct trace_reader_conf *conf)
{
    conf->free_dead_process_metadata = TRUE;
    return process_files_with_error_recovery(conf, TRUE, TRACE_PARSER__dump);
}

static int dump_statistics_for_all_files(struct trace_reader_conf *conf)
{
    conf->free_dead_process_metadata = FALSE;
    return process_files_with_error_recovery(conf, FALSE, TRACE_PARSER__dump_statistics);
}

static int dump_metadata_for_files(struct trace_reader_conf *conf)
{
    conf->free_dead_process_metadata = FALSE;
    return process_files_with_error_recovery(conf, FALSE, TRACE_PARSER__dump_all_metadata);
}

static void init_conf(struct trace_reader_conf *conf, int argc, const char **argv)
{
    memset(conf, 0, sizeof(*conf));
    int rc = parse_command_line(conf, argc, argv);
    if (0 != rc)
        exit_usage(argv[0], NULL);

    set_conf_filter(conf);
}

int main(int argc, const char **argv)
{
    struct trace_reader_conf conf;
    init_conf(&conf, argc, argv);

    switch (conf.op_type) {
    case OP_TYPE_DUMP_STATS:
        return dump_statistics_for_all_files(&conf);
        break;
    case OP_TYPE_DUMP_FILE:
        return dump_all_files(&conf);
        break;
    case OP_TYPE_DUMP_METADATA:
        return dump_metadata_for_files(&conf);
        break;
    case OP_TYPE_INVALID:
        exit_usage(argv[0], "Invalid paramter");
        break;

    default:
        break;
    }
    
    return 0;
}
